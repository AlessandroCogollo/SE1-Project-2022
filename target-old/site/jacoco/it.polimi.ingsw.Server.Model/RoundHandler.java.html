<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RoundHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">AM56</a> &gt; <a href="index.source.html" class="el_package">it.polimi.ingsw.Server.Model</a> &gt; <span class="el_source">RoundHandler.java</span></div><h1>RoundHandler.java</h1><pre class="source lang-java linenums">package it.polimi.ingsw.Server.Model;

import java.util.*;


//this class cycle throw the phase and the player to keep track of all moves done, needs to run start() in order to start the game
class RoundHandler {

    private final GameInitializer gInit;

    //except for the 1' round the planning phase is always equal to the last action phase but considering that the queue uses a destructive getters we need one queue for all the 2 phase
    private final Queue&lt;Player&gt; actionOrder; // the order during the action phase
    private final Queue&lt;Player&gt; planningOrder; // the order during the planning phase
    private final Queue&lt;Player&gt; specialOrder; // for track the case when a player has all the assistant equals to the others

    // the current state of the game
    private Phase phase;
    private ActionPhase actionPhase;
    private Player current;
    private int studentMovedInThisTurn;
    private boolean isFinalRound;

    // random for the initial player
    private final Random rand;

<span class="fc" id="L26">    RoundHandler(GameInitializer gameInitializer) {</span>
<span class="fc" id="L27">        this.current = null;</span>
<span class="fc" id="L28">        this.rand = new Random(System.currentTimeMillis());</span>

<span class="fc" id="L30">        this.actionOrder = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L31">        this.planningOrder = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L32">        this.specialOrder = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L33">        this.gInit = gameInitializer;</span>
<span class="fc" id="L34">        this.studentMovedInThisTurn = 0;</span>
<span class="fc" id="L35">        this.isFinalRound = false;</span>
<span class="fc" id="L36">    }</span>

    Player getCurrent() {
<span class="fc" id="L39">        return current;</span>
    }

    Phase getPhase() {
<span class="fc" id="L43">        return phase;</span>
    }

    ActionPhase getActionPhase() {
<span class="fc" id="L47">        return actionPhase;</span>
    }

    int getStudentMovedInThisTurn() {
<span class="fc" id="L51">        return studentMovedInThisTurn;</span>
    }

    boolean getIsFinalRound() {
<span class="fc" id="L55">        return isFinalRound;</span>
    }

    void setFinalRound() {
<span class="fc" id="L59">        isFinalRound = true;</span>
<span class="fc" id="L60">    }</span>

    //return true if the player can play the assistant considering all the exception
    boolean canPLayAssistant (Player p, Assistant x){

<span class="fc" id="L65">        boolean canPlay = true;</span>
<span class="fc" id="L66">        Collection&lt;Assistant&gt; assistantPlayed = new ArrayList&lt;&gt;();</span>

        // iterating over all player != p
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (Player player : gInit) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (!p.equals(player)) {</span>

<span class="fc" id="L72">                Assistant temp = player.getActiveAssistant();</span>

                //setting up a temporary list for later
<span class="fc" id="L75">                assistantPlayed.add(temp);</span>


                // if one other player has a not null assistant that is equal to the one that the player p wants to play (x) the boolean is set to false for now
<span class="fc bfc" id="L79" title="All 4 branches covered.">                if (temp != null &amp;&amp; temp.equals(x))</span>
<span class="fc" id="L80">                    canPlay = false;</span>
            }
<span class="fc" id="L82">        }</span>

        //if the assistant x is unique return true
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (canPlay)</span>
<span class="fc" id="L86">            return true;</span>

        // test for all equals assistant
<span class="fc" id="L89">        boolean allEqual = true;</span>

        //cycle over all assistants in p's deck
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (Assistant a: p){</span>

            //if there is an assistant in p's deck that isn't played he can play that one instead of x Assistant
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (!assistantPlayed.contains(a)){</span>
<span class="fc" id="L96">                allEqual = false;</span>
<span class="fc" id="L97">                break;</span>
            }
<span class="fc" id="L99">        }</span>

        //if we found that the player can actually play the assistant x we add the player in the special order and we return true
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (allEqual) {</span>
<span class="fc" id="L103">            specialOrder.add(p);</span>
<span class="fc" id="L104">            return true;</span>
        }
<span class="fc" id="L106">        return false;</span>
    }

    //set the initial state
    void start (){
        //initial phase
<span class="fc" id="L112">        phase = Phase.Planning;</span>
<span class="fc" id="L113">        actionPhase = ActionPhase.NotActionPhase;</span>

        //set the initial order

        //get a random player
<span class="fc" id="L118">        int randomId = getRandomPlayerId();</span>
<span class="fc" id="L119">        Player p = gInit.getPlayerById(randomId);</span>


<span class="fc" id="L122">        LinkedList&lt;Player&gt; temp = new LinkedList&lt;&gt;();</span>

        //we insert first the one extracted, and all the player before him in the iterator gInit will be added to the temp queue in the correct order
<span class="fc" id="L125">        boolean insertedFirst = false;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (Player t: gInit){</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (!insertedFirst) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                if (t.equals(p)) {</span>
<span class="fc" id="L129">                    planningOrder.add(t);</span>
<span class="fc" id="L130">                    insertedFirst = true;</span>
                } else {
<span class="fc" id="L132">                    temp.add(t);</span>
                }
            }
            else
<span class="fc" id="L136">                planningOrder.add(t);</span>
<span class="fc" id="L137">        }</span>

        // now we add all the player in temp to the right queue
<span class="fc bfc" id="L140" title="All 2 branches covered.">        while (!temp.isEmpty()){</span>
<span class="fc" id="L141">            planningOrder.add(temp.poll());</span>
        }

        //we set the current player with the one extracted
<span class="fc" id="L145">        current = planningOrder.poll();</span>
<span class="fc" id="L146">    }</span>

    //cycle between the phase
    void next (){

        //planning phase
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (phase.equals(Phase.Planning)){</span>

            //during the planning phase we iter before throw player and then to the next phase

            //change to action phase
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (planningOrder.isEmpty()) {</span>
<span class="fc" id="L158">                setOrder();</span>
<span class="fc" id="L159">                phase = Phase.Action;</span>
<span class="fc" id="L160">                actionPhase = ActionPhase.MoveStudent;</span>
<span class="fc" id="L161">                current = actionOrder.poll();</span>
            }
            //or next player
            else
<span class="fc" id="L165">                current = planningOrder.poll();</span>
        }

        //action phase
        else {

            //during the action phase we iter before throw action phase and then to the next player
<span class="pc bpc" id="L172" title="2 of 5 branches missed.">            switch (actionPhase){</span>
                case NotActionPhase:
                    //win
<span class="nc" id="L175">                    break;</span>
                case MoveStudent:
<span class="fc" id="L177">                    studentMovedInThisTurn++;</span>
<span class="fc" id="L178">                    int playerNum = gInit.getPlayersNumber();</span>
<span class="pc bpc" id="L179" title="1 of 10 branches missed.">                    if (((playerNum == 2 || playerNum == 4) &amp;&amp; studentMovedInThisTurn == 3) || (playerNum == 3 &amp;&amp; studentMovedInThisTurn == 4)){</span>
<span class="fc" id="L180">                        actionPhase = ActionPhase.MoveMotherNature;</span>
<span class="fc" id="L181">                        studentMovedInThisTurn = 0;</span>
                    }
                    break;
                case MoveMotherNature:
<span class="fc" id="L185">                    actionPhase = ActionPhase.ChooseCloud;</span>
<span class="fc" id="L186">                    break;</span>
                case ChooseCloud:
<span class="fc" id="L188">                    gInit.getBoard().playCharacter(null, null); //reset active character</span>

                    //return to planning
<span class="fc bfc" id="L191" title="All 2 branches covered.">                    if (actionOrder.isEmpty()) {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                        if (isFinalRound){</span>
<span class="nc" id="L193">                            phase = Phase.Action;</span>
<span class="nc" id="L194">                            actionPhase = ActionPhase.NotActionPhase;</span>
<span class="nc" id="L195">                            gInit.checkWin();</span>
<span class="nc" id="L196">                            break;</span>
                        }
<span class="fc" id="L198">                        phase = Phase.Planning;</span>
<span class="fc" id="L199">                        actionPhase = ActionPhase.NotActionPhase;</span>
<span class="fc" id="L200">                        resetActiveAssistants();</span>
<span class="fc" id="L201">                        gInit.getBoard().populateClouds();</span>
<span class="fc" id="L202">                        current = planningOrder.poll();</span>
                    }
                    //or to the next player and the next action phase
                    else {
<span class="fc" id="L206">                        current = actionOrder.poll();</span>
<span class="fc" id="L207">                        actionPhase = ActionPhase.MoveStudent;</span>
                    }
                    break;
            }
        }
<span class="fc" id="L212">    }</span>

    //select a random player id
    private int getRandomPlayerId (){
<span class="fc" id="L216">        int[] ids = new int[gInit.getPlayersNumber()];</span>
<span class="fc" id="L217">        int i = 0;</span>
        Player p;
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (Player player : gInit) {</span>
<span class="fc" id="L220">            p = player;</span>
<span class="fc" id="L221">            ids[i] = p.getId();</span>
<span class="fc" id="L222">            i++;</span>
<span class="fc" id="L223">        }</span>
<span class="fc" id="L224">        return ids[rand.nextInt(gInit.getPlayersNumber())];</span>
    }

    private void resetActiveAssistants() {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        for (Player p: gInit)</span>
<span class="fc" id="L229">            p.playAssistant(null);</span>
<span class="fc" id="L230">    }</span>

    //set the order of the player during the next action phase and the following planning phase thanks to the active assistant of the players
    private void setOrder(){
<span class="fc" id="L234">        final int id = 0;</span>
<span class="fc" id="L235">        final int value = 1;</span>

        //we create a matrix 2xNumberOfPlayers with in the first row all the ids and in the second row alla the value of their active assistant
<span class="fc" id="L238">        int[][] arr = new int[2][gInit.getPlayersNumber()];</span>
<span class="fc" id="L239">        int i = 0;</span>
        Player x;
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (Player player : gInit) {</span>
<span class="fc" id="L242">            x = player;</span>
<span class="fc" id="L243">            arr[id][i] = x.getId();</span>
<span class="fc" id="L244">            arr[value][i] = x.getActiveAssistant().getValue();</span>
<span class="fc" id="L245">            i++;</span>
<span class="fc" id="L246">        }</span>

        //we sort the column of the matrix  comparing the value of the active assistant
<span class="fc" id="L249">        sortMatrixColumn(arr, 1);</span>

        //special case when a player has the same assistant as the others
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (!specialOrder.isEmpty()){</span>
            Player temp;
            int tempId;
<span class="fc bfc" id="L255" title="All 2 branches covered.">            while (!specialOrder.isEmpty()){</span>

                //we select the one in the special queue
<span class="fc" id="L258">                temp = specialOrder.poll();</span>
<span class="fc" id="L259">                tempId = temp.getId();</span>

                //and we search his id in the matrix saving his index i
<span class="fc" id="L262">                i = 0;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                while (arr[id][i] != tempId){</span>
<span class="nc" id="L264">                    i++;</span>
                }

                //considering that the matrix is ordered from the one with the smallest value to the one with the max value, player with the same value are in a random order, so to make that the first one who has played the assistant is the first, for all the others players in this special queue (the first that has play the assistant isn't in the queue) we shift them to the last position with the same value. So, int this way also for multiple player with the same assistant we keep the correct order
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">                while (arr[value][i] == arr[value][i + 1] &amp;&amp; i &lt; gInit.getPlayersNumber() - 1){</span>
<span class="fc" id="L269">                    swap (arr, i, i + 1);</span>
<span class="fc" id="L270">                    i++;</span>
                }
            }
        }

        //now in all cases in the matrix there's the correct order so we insert it in each queue
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (i = 0; i &lt; gInit.getPlayersNumber(); i++){</span>
<span class="fc" id="L277">            actionOrder.add(gInit.getPlayerById(arr[id][i]));</span>
<span class="fc" id="L278">            planningOrder.add(gInit.getPlayerById(arr[id][i]));</span>
        }
<span class="fc" id="L280">    }</span>

    //todo more object oriented
    //sort the matrix column considering only the index passed as parameter in O(n^2)
    private static void sortMatrixColumn (int[][] matrix, int rowToCompare){
<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (int i = 0; i &lt; matrix[0].length; i++) {</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            for (int j = i + 1; j &lt; matrix[0].length; j++) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                if (matrix[rowToCompare][i] &gt; matrix[rowToCompare][j]) {</span>
<span class="fc" id="L288">                    swap(matrix, i, j);</span>
                }
            }
        }
<span class="fc" id="L292">    }</span>

    //swap two column of a matrix with 2 row
    private static void swap (int[][] matrix, int index1, int index2){
        int tmp0, tmp1;
<span class="fc" id="L297">        tmp0 = matrix[0][index1];</span>
<span class="fc" id="L298">        tmp1 = matrix[1][index1];</span>
<span class="fc" id="L299">        matrix[0][index1] = matrix[0][index2];</span>
<span class="fc" id="L300">        matrix[1][index1] = matrix[1][index2];</span>
<span class="fc" id="L301">        matrix[0][index2] = tmp0;</span>
<span class="fc" id="L302">        matrix[1][index2] = tmp1;</span>
<span class="fc" id="L303">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>